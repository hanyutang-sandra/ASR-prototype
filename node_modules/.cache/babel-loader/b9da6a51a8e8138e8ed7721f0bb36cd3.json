{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar grpc = require(\"grpc\");\n\nvar util = require(\"util\");\n\nvar gcp_channel_factory_1 = require(\"./gcp_channel_factory\");\n\nexports.GcpChannelFactory = gcp_channel_factory_1.GcpChannelFactory;\n\nvar protoRoot = require(\"./generated/grpc_gcp\");\n\nvar ApiConfig = protoRoot.grpc.gcp.ApiConfig;\nvar AffinityConfig = protoRoot.grpc.gcp.AffinityConfig;\n/**\n * Create ApiConfig proto message from config object.\n * @param apiDefinition Api object that specifies channel pool configuation.\n * @return A protobuf message type.\n */\n\nfunction createGcpApiConfig(apiDefinition) {\n  return ApiConfig.fromObject(apiDefinition);\n}\n\nexports.createGcpApiConfig = createGcpApiConfig;\n/**\n * Function for creating a gcp channel factory.\n * @memberof grpc-gcp\n * @param address The address of the server to connect to.\n * @param credentials Channel credentials to use when connecting\n * @param options A map of channel options that will be passed to the core.\n * @return {GcpChannelFactory} A GcpChannelFactory instance.\n */\n\nfunction gcpChannelFactoryOverride(address, credentials, options) {\n  return new gcp_channel_factory_1.GcpChannelFactory(address, credentials, options);\n}\n\nexports.gcpChannelFactoryOverride = gcpChannelFactoryOverride;\n/**\n * Pass in call properties and return a new object with modified values.\n * This function will be used together with gcpChannelFactoryOverride\n * when constructing a grpc Client.\n * @memberof grpc-gcp\n * @param callProperties Call properties with channel factory object.\n * @return Modified call properties with selected grpc channel object.\n */\n\nfunction gcpCallInvocationTransformer(callProperties) {\n  var channelFactory = callProperties.channel;\n\n  if (!channelFactory || !(channelFactory instanceof gcp_channel_factory_1.GcpChannelFactory)) {\n    // The gcpCallInvocationTransformer needs to use gcp channel factory.\n    return callProperties;\n  }\n\n  var argument = callProperties.argument;\n  var metadata = callProperties.metadata;\n  var call = callProperties.call;\n  var methodDefinition = callProperties.methodDefinition;\n  var path = methodDefinition.path;\n  var callOptions = callProperties.callOptions;\n  var callback = callProperties.callback;\n  var preProcessResult = preProcess(channelFactory, path, argument);\n  var channelRef = preProcessResult.channelRef;\n  var boundKey = preProcessResult.boundKey;\n\n  var postProcessInterceptor = function postProcessInterceptor( // tslint:disable-next-line:no-any options can be any object\n  options, nextCall) {\n    // tslint:disable-next-line:no-any protobuf message\n    var firstMessage;\n    var requester = {\n      start: function start(metadata, listener, next) {\n        var newListener = {\n          onReceiveMetadata: function onReceiveMetadata(metadata, next) {\n            next(metadata);\n          },\n          // tslint:disable-next-line:no-any protobuf message\n          onReceiveMessage: function onReceiveMessage(message, next) {\n            if (!firstMessage) firstMessage = message;\n            next(message);\n          },\n          onReceiveStatus: function onReceiveStatus(status, next) {\n            if (status.code === grpc.status.OK) {\n              postProcess(channelFactory, channelRef, path, boundKey, firstMessage);\n            }\n\n            next(status);\n          }\n        };\n        next(metadata, newListener);\n      },\n      // tslint:disable-next-line:no-any protobuf message\n      sendMessage: function sendMessage(message, next) {\n        next(message);\n      },\n      halfClose: function halfClose(next) {\n        next();\n      },\n      cancel: function cancel(next) {\n        next();\n      }\n    };\n    return new grpc.InterceptingCall(nextCall(options), requester);\n  }; // Append interceptor to existing interceptors list.\n\n\n  var newCallOptions = Object.assign({}, callOptions);\n  var interceptors = callOptions.interceptors ? callOptions.interceptors : [];\n  newCallOptions.interceptors = interceptors.concat([postProcessInterceptor]);\n  return {\n    argument: argument,\n    metadata: metadata,\n    call: call,\n    channel: channelRef.getChannel(),\n    methodDefinition: methodDefinition,\n    callOptions: newCallOptions,\n    callback: callback\n  };\n}\n\nexports.gcpCallInvocationTransformer = gcpCallInvocationTransformer;\n/**\n * Handle channel affinity and pick a channel before call starts.\n * @param channelFactory The channel management factory.\n * @param path Method path.\n * @param argument The request arguments object.\n * @return Result containing bound affinity key and the chosen channel ref\n * object.\n */\n\nfunction preProcess(channelFactory, path, // tslint:disable-next-line:no-any protobuf message\nargument) {\n  var affinityConfig = channelFactory.getAffinityConfig(path);\n  var boundKey;\n\n  if (argument && affinityConfig) {\n    var command = affinityConfig.command;\n\n    if (command === AffinityConfig.Command.BOUND || command === AffinityConfig.Command.UNBIND) {\n      boundKey = getAffinityKeyFromMessage(affinityConfig.affinityKey, argument);\n    }\n  }\n\n  var channelRef = channelFactory.getChannelRef(boundKey);\n  channelRef.activeStreamsCountIncr();\n  return {\n    boundKey: boundKey,\n    channelRef: channelRef\n  };\n}\n/**\n * Handle channel affinity and streams count after call is done.\n * @param channelFactory The channel management factory.\n * @param channelRef ChannelRef instance that contains a real grpc channel.\n * @param path Method path.\n * @param boundKey Affinity key bound to a channel.\n * @param responseMsg Response proto message.\n */\n\n\nfunction postProcess(channelFactory, channelRef, path, boundKey, // tslint:disable-next-line:no-any protobuf message\nresponseMsg) {\n  if (!channelFactory || !responseMsg) return;\n  var affinityConfig = channelFactory.getAffinityConfig(path);\n\n  if (affinityConfig && affinityConfig.command) {\n    var command = affinityConfig.command;\n\n    if (command === AffinityConfig.Command.BIND) {\n      var affinityKey = getAffinityKeyFromMessage(affinityConfig.affinityKey, responseMsg);\n      channelFactory.bind(channelRef, affinityKey);\n    } else if (command === AffinityConfig.Command.UNBIND) {\n      channelFactory.unbind(boundKey);\n    }\n  }\n\n  channelRef.activeStreamsCountDecr();\n}\n/**\n * Retrieve affinity key specified in the proto message.\n * @param affinityKeyName affinity key locator.\n * @param message proto message that contains affinity info.\n * @return Affinity key string.\n */\n\n\nfunction getAffinityKeyFromMessage(affinityKeyName, // tslint:disable-next-line:no-any protobuf message\nmessage) {\n  if (affinityKeyName) {\n    var currMessage = message;\n    var names = affinityKeyName.split('.');\n    var i = 0;\n\n    for (; i < names.length; i++) {\n      if (currMessage[names[i]]) {\n        // check if the proto message is generated by protobufjs.\n        currMessage = currMessage[names[i]];\n      } else {\n        // otherwise use jspb format.\n        var getter = 'get' + names[i].charAt(0).toUpperCase() + names[i].substr(1);\n        if (!currMessage || typeof currMessage[getter] !== 'function') break;\n        currMessage = currMessage[getter]();\n      }\n    }\n\n    if (i !== 0 && i === names.length) return currMessage;\n  }\n\n  console.error(util.format('Cannot find affinity value from proto message using affinity_key: %s.', affinityKeyName));\n  return '';\n}","map":null,"metadata":{},"sourceType":"script"}